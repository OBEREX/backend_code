-- ============================================
-- PEFOMA SUPABASE SCHEMA - CANONICAL VERSION
-- ============================================

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================
-- 1. USER PROFILES (Enhanced for Frontend Requirements)
-- ============================================

DROP TABLE IF EXISTS public.profiles CASCADE;

CREATE TABLE public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    -- Required registration fields (from SignUp.tsx)
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    phone TEXT NOT NULL,
    company TEXT NOT NULL,
    business_type TEXT NOT NULL,
    city TEXT NOT NULL,
    state TEXT NOT NULL,
    -- Account status
    is_verified BOOLEAN DEFAULT false,
    verification_method TEXT CHECK (verification_method IN ('email', 'phone')),
    verified_at TIMESTAMP WITH TIME ZONE,
    -- Usage tracking
    is_guest BOOLEAN DEFAULT false,
    guest_converted_at TIMESTAMP WITH TIME ZONE,
    last_login TIMESTAMP WITH TIME ZONE,
    -- Subscription/limits
    account_tier TEXT DEFAULT 'free' CHECK (account_tier IN ('guest', 'free', 'premium', 'enterprise')),
    daily_query_limit INTEGER DEFAULT 10,
    queries_used_today INTEGER DEFAULT 0,
    -- Profile settings (from Settings.tsx)
    avatar_url TEXT,
    theme TEXT DEFAULT 'auto' CHECK (theme IN ('light', 'dark', 'auto')),
    language TEXT DEFAULT 'en',
    timezone TEXT DEFAULT 'UTC',
    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create indexes
CREATE INDEX idx_profiles_email ON public.profiles(email);
CREATE INDEX idx_profiles_phone ON public.profiles(phone);
CREATE INDEX idx_profiles_verified ON public.profiles(is_verified);
CREATE INDEX idx_profiles_tier ON public.profiles(account_tier);

-- Enable RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own profile" ON public.profiles
    FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update own profile" ON public.profiles
    FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Service role can manage all profiles" ON public.profiles
    FOR ALL USING (auth.jwt() ->> 'role' = 'service_role');

-- ============================================
-- 2. OTP VERIFICATION (Enhanced for Password Reset)
-- ============================================

DROP TABLE IF EXISTS public.otp_tokens;
CREATE TABLE public.otp_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT,
    phone_number TEXT,
    token_hash TEXT NOT NULL, -- hashed token for security
    token_type TEXT NOT NULL CHECK (token_type IN ('registration', 'login', 'password_reset', 'email_verification')),
    is_used BOOLEAN DEFAULT false,
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    used_at TIMESTAMP WITH TIME ZONE,
    CHECK (email IS NOT NULL OR phone_number IS NOT NULL)
);

CREATE INDEX idx_otp_tokens_email ON public.otp_tokens(email);
CREATE INDEX idx_otp_tokens_phone ON public.otp_tokens(phone_number);
CREATE INDEX idx_otp_tokens_expires ON public.otp_tokens(expires_at);
CREATE INDEX idx_otp_tokens_type ON public.otp_tokens(token_type);

-- ============================================
-- 3. SECURE OTP FUNCTIONS
-- ============================================

-- Enhanced OTP generation with rate limiting
DROP FUNCTION generate_otp(text,text,text);
CREATE FUNCTION generate_otp(
    p_email TEXT DEFAULT NULL,
    p_phone TEXT DEFAULT NULL,
    p_type TEXT DEFAULT 'registration'
) RETURNS JSONB AS $$
DECLARE
    v_token TEXT;
    v_user_id UUID;
    v_recent_count INTEGER;
BEGIN
    -- Rate limiting: max 3 OTP requests per hour
    SELECT COUNT(*) INTO v_recent_count
    FROM public.otp_tokens
    WHERE (
        (p_email IS NOT NULL AND email = p_email) OR
        (p_phone IS NOT NULL AND phone_number = p_phone)
    )
    AND token_type = p_type
    AND created_at > NOW() - INTERVAL '1 hour';
    
    IF v_recent_count >= 3 THEN
        RETURN jsonb_build_object(
            'success', false, 
            'error', 'Too many OTP requests. Please wait before trying again.'
        );
    END IF;

    -- Generate 6-digit OTP
    v_token := LPAD(FLOOR(RANDOM() * 1000000)::TEXT, 6, '0');

    -- Get user_id if exists
    IF p_email IS NOT NULL THEN
        SELECT id INTO v_user_id FROM auth.users WHERE email = p_email;
    END IF;

    -- Invalidate previous unused tokens
    UPDATE public.otp_tokens
    SET is_used = true, used_at = NOW()
    WHERE (
        (p_email IS NOT NULL AND email = p_email) OR
        (p_phone IS NOT NULL AND phone_number = p_phone)
    )
    AND token_type = p_type
    AND is_used = false;

    -- Insert new hashed token
    INSERT INTO public.otp_tokens (
        user_id, email, phone_number, token_hash, token_type, expires_at
    ) VALUES (
        v_user_id, p_email, p_phone, crypt(v_token, gen_salt('bf')), p_type, NOW() + INTERVAL '10 minutes'
    );

    RETURN jsonb_build_object(
        'success', true, 
        'token', v_token,  -- Return for secure transmission
        'expires_in_minutes', 10
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Enhanced OTP verification with attempt limiting

CREATE OR REPLACE FUNCTION verify_otp(
    p_token TEXT,
    p_email TEXT DEFAULT NULL,
    p_phone TEXT DEFAULT NULL,
    p_type TEXT DEFAULT 'registration'
) RETURNS JSONB AS $$
DECLARE
    v_token_record RECORD;
BEGIN
    -- Find the most recent unused token
    SELECT * INTO v_token_record
    FROM public.otp_tokens
    WHERE is_used = false
      AND expires_at > NOW()
      AND token_type = p_type
      AND attempts < max_attempts
      AND (
          (p_email IS NOT NULL AND email = p_email) OR
          (p_phone IS NOT NULL AND phone_number = p_phone)
      )
    ORDER BY created_at DESC
    LIMIT 1;

    -- If no token found
    IF v_token_record IS NULL THEN
        RETURN jsonb_build_object(
            'success', false, 
            'error', 'Invalid, expired, or locked OTP'
        );
    END IF;

    -- Increment attempts
    UPDATE public.otp_tokens
    SET attempts = attempts + 1
    WHERE id = v_token_record.id;

    -- Verify token
    IF NOT crypt(p_token, v_token_record.token_hash) = v_token_record.token_hash THEN
        -- Check if max attempts reached
        IF v_token_record.attempts + 1 >= v_token_record.max_attempts THEN
            UPDATE public.otp_tokens
            SET is_used = true, used_at = NOW()
            WHERE id = v_token_record.id;
            
            RETURN jsonb_build_object(
                'success', false, 
                'error', 'Maximum verification attempts exceeded. Please request a new OTP.'
            );
        END IF;
        
        RETURN jsonb_build_object(
            'success', false, 
            'error', 'Invalid OTP',
            'attempts_remaining', v_token_record.max_attempts - (v_token_record.attempts + 1)
        );
    END IF;

    -- Mark token as used
    UPDATE public.otp_tokens
    SET is_used = true, used_at = NOW()
    WHERE id = v_token_record.id;

    -- Update user verification status for registration
    IF v_token_record.token_type = 'registration' AND v_token_record.user_id IS NOT NULL THEN
        UPDATE public.profiles
        SET 
            is_verified = true,
            verified_at = NOW(),
            verification_method = CASE WHEN v_token_record.email IS NOT NULL THEN 'email' ELSE 'phone' END
        WHERE id = v_token_record.user_id;
    END IF;

    RETURN jsonb_build_object(
        'success', true, 
        'user_id', v_token_record.user_id,
        'token_type', v_token_record.token_type
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 4. PASSWORD RESET TOKEN MANAGEMENT
-- ============================================

CREATE TABLE public.password_reset_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT NOT NULL,
    token_hash TEXT NOT NULL,
    is_used BOOLEAN DEFAULT false,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    used_at TIMESTAMP WITH TIME ZONE
);

CREATE INDEX idx_password_reset_tokens_email ON public.password_reset_tokens(email);
CREATE INDEX idx_password_reset_tokens_expires ON public.password_reset_tokens(expires_at);

-- Generate password reset token
CREATE OR REPLACE FUNCTION generate_password_reset_token(p_email TEXT)
RETURNS JSONB AS $$
DECLARE
    v_token TEXT;
    v_user_id UUID;
    v_recent_count INTEGER;
BEGIN
    -- Check if user exists
    SELECT id INTO v_user_id FROM auth.users WHERE email = p_email;
    
    IF v_user_id IS NULL THEN
        -- Don't reveal if user exists, return success anyway
        RETURN jsonb_build_object(
            'success', true,
            'message', 'If this email exists, you will receive password reset instructions.'
        );
    END IF;

    -- Rate limiting: max 3 reset requests per hour
    SELECT COUNT(*) INTO v_recent_count
    FROM public.password_reset_tokens
    WHERE email = p_email
    AND created_at > NOW() - INTERVAL '1 hour';
    
    IF v_recent_count >= 3 THEN
        RETURN jsonb_build_object(
            'success', false, 
            'error', 'Too many reset requests. Please wait before trying again.'
        );
    END IF;

    -- Generate secure token
    v_token := encode(gen_random_bytes(32), 'base64');
    v_token := replace(replace(replace(v_token, '/', '_'), '+', '-'), '=', '');

    -- Invalidate previous tokens
    UPDATE public.password_reset_tokens
    SET is_used = true, used_at = NOW()
    WHERE email = p_email AND is_used = false;

    -- Insert new token
    INSERT INTO public.password_reset_tokens (
        user_id, email, token_hash, expires_at
    ) VALUES (
        v_user_id, p_email, crypt(v_token, gen_salt('bf')), NOW() + INTERVAL '1 hour'
    );

    RETURN jsonb_build_object(
        'success', true,
        'token', v_token,
        'expires_in_minutes', 60
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Verify password reset token
CREATE OR REPLACE FUNCTION verify_password_reset_token(p_token TEXT)
RETURNS JSONB AS $$
DECLARE
    v_token_record RECORD;
BEGIN
    SELECT * INTO v_token_record
    FROM public.password_reset_tokens
    WHERE is_used = false
      AND expires_at > NOW()
      AND crypt(p_token, token_hash) = token_hash
    LIMIT 1;

    IF v_token_record IS NULL THEN
        RETURN jsonb_build_object(
            'success', false, 
            'error', 'Invalid or expired reset token'
        );
    END IF;

    RETURN jsonb_build_object(
        'success', true, 
        'user_id', v_token_record.user_id,
        'email', v_token_record.email
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 5. USER MANAGEMENT FUNCTIONS
-- ============================================

-- Create or update profile (for Django sync)
CREATE OR REPLACE FUNCTION upsert_profile(
    p_user_id UUID,
    p_first_name TEXT,
    p_last_name TEXT,
    p_email TEXT,
    p_phone TEXT,
    p_company TEXT,
    p_business_type TEXT,
    p_city TEXT,
    p_state TEXT
) RETURNS UUID AS $$
BEGIN
    INSERT INTO public.profiles (
        id, first_name, last_name, email, phone, company, business_type, city, state
    ) VALUES (
        p_user_id, p_first_name, p_last_name, p_email, p_phone, p_company, p_business_type, p_city, p_state
    )
    ON CONFLICT (id) DO UPDATE SET
        first_name = EXCLUDED.first_name,
        last_name = EXCLUDED.last_name,
        email = EXCLUDED.email,
        phone = EXCLUDED.phone,
        company = EXCLUDED.company,
        business_type = EXCLUDED.business_type,
        city = EXCLUDED.city,
        state = EXCLUDED.state,
        updated_at = NOW();
    
    RETURN p_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Update last login
CREATE OR REPLACE FUNCTION update_last_login(p_user_id UUID)
RETURNS VOID AS $$
BEGIN
    UPDATE public.profiles
    SET last_login = NOW(), updated_at = NOW()
    WHERE id = p_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 6. CLEANUP FUNCTIONS
-- ============================================

-- Clean expired tokens (to be run periodically)
CREATE OR REPLACE FUNCTION cleanup_expired_tokens()
RETURNS INTEGER AS $$
DECLARE
    v_deleted_count INTEGER := 0;
    v_last_count INTEGER := 0;
BEGIN
    -- ensure search_path is empty for security
    SET LOCAL search_path = '';

    DELETE FROM public.otp_tokens WHERE expires_at < NOW() - INTERVAL '24 hours';
    GET DIAGNOSTICS v_last_count = ROW_COUNT;
    v_deleted_count := v_deleted_count + v_last_count;

    DELETE FROM public.password_reset_tokens WHERE expires_at < NOW() - INTERVAL '24 hours';
    GET DIAGNOSTICS v_last_count = ROW_COUNT;
    v_deleted_count := v_deleted_count + v_last_count;

    RETURN v_deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 7. TRIGGERS
-- ============================================

-- Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_profiles_timestamp
    BEFORE UPDATE ON public.profiles
    FOR EACH ROW EXECUTE FUNCTION update_timestamp();

-- ============================================
-- 8. INITIAL DATA
-- ============================================

-- Business type constraints (based on SignUp.tsx options)
ALTER TABLE public.profiles DROP CONSTRAINT IF EXISTS profiles_business_type_check;
ALTER TABLE public.profiles ADD CONSTRAINT profiles_business_type_check 
CHECK (business_type IN (
    'Retail & E-Commerce',
    'Wholesale & Distribution', 
    'Manufacturing',
    'Restaurant & Food Service',
    'Healthcare & Pharmacy',
    'Automotive',
    'Construction & Hardware',
    'Technology & Electronics',
    'Fashion & Apparel',
    'Agriculture & Farming',
    'Logistics & Warehousing',
    'Education & Training',
    'Non-Profit Organization',
    'Other'
));

-- ============================================
-- 9. SECURITY FUNCTIONS
-- ============================================

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO authenticated, anon;
GRANT SELECT, INSERT, UPDATE ON public.profiles TO authenticated, anon;
GRANT SELECT, INSERT, UPDATE ON public.otp_tokens TO authenticated, anon;
GRANT SELECT, INSERT, UPDATE ON public.password_reset_tokens TO authenticated, anon;

-- Grant execute on functions
GRANT EXECUTE ON FUNCTION generate_otp TO authenticated, anon;
GRANT EXECUTE ON FUNCTION verify_otp TO authenticated, anon;
GRANT EXECUTE ON FUNCTION generate_password_reset_token TO authenticated, anon;
GRANT EXECUTE ON FUNCTION verify_password_reset_token TO authenticated, anon;
GRANT EXECUTE ON FUNCTION upsert_profile TO authenticated, anon;
GRANT EXECUTE ON FUNCTION update_last_login TO authenticated, anon;